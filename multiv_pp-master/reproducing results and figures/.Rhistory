vs1w_list$ens[rr, ] <- tmp$vs1w
vs0_list$ens[rr, ] <- tmp$vs0
vs0w_list$ens[rr, ] <- tmp$vs0w
# EMOS.Q
emos.q <- mvpp(method = "EMOS", variant = "Q", ensfc = fc$ensfc, ensfc_init = fc$ensfc_init,
obs = obs$obs, obs_init = obs$obs_init, postproc_out = pp_out)
if(compute_crps){
crps_list$emos.q[rr, , ] <- crps_wrapper(emos.q, obs$obs)
}
tmp <- eval_all_mult(mvpp_out = emos.q, obs = obs$obs)
es_list$emos.q[rr, ] <- tmp$es
vs1_list$emos.q[rr, ] <- tmp$vs1
vs1w_list$emos.q[rr, ] <- tmp$vs1w
vs0_list$emos.q[rr, ] <- tmp$vs0
vs0w_list$emos.q[rr, ] <- tmp$vs0w
# ECC.Q
ecc.q <- mvpp(method = "ECC", ensfc = fc$ensfc, ensfc_init = fc$ensfc_init,
obs = obs$obs, obs_init = obs$obs_init, postproc_out = pp_out,
EMOS_sample = emos.q)
if(compute_crps){
crps_list$ecc.q[rr, , ] <- crps_wrapper(ecc.q, obs$obs)
}
tmp <- eval_all_mult(mvpp_out = ecc.q, obs = obs$obs)
es_list$ecc.q[rr, ] <- tmp$es
vs1_list$ecc.q[rr, ] <- tmp$vs1
vs1w_list$ecc.q[rr, ] <- tmp$vs1w
vs0_list$ecc.q[rr, ] <- tmp$vs0
vs0w_list$ecc.q[rr, ] <- tmp$vs0w
# ECC.S -> involves randomness -> repeat rand_rep times
es_list_tmp <- vs1_list_tmp <- vs1w_list_tmp <-
vs0_list_tmp <- vs0w_list_tmp <- matrix(NA, nrow = nout, ncol = rand_rep)
crps_list_tmp <- array(NA, dim = c(nout, d, rand_rep))
for(RR in 1:rand_rep){
emos.s <- mvpp(method = "EMOS", variant = "S", ensfc = fc$ensfc, ensfc_init = fc$ensfc_init,
obs = obs$obs, obs_init = obs$obs_init, postproc_out = pp_out)
ecc.s <- mvpp(method = "ECC", ensfc = fc$ensfc, ensfc_init = fc$ensfc_init,
obs = obs$obs, obs_init = obs$obs_init, postproc_out = pp_out,
EMOS_sample = emos.s)
if(compute_crps){
crps_list_tmp[,,RR] <- crps_wrapper(ecc.s, obs$obs)
}
tmp <- eval_all_mult(mvpp_out = ecc.s, obs = obs$obs)
es_list_tmp[,RR] <- tmp$es
vs1_list_tmp[,RR] <- tmp$vs1
vs1w_list_tmp[,RR] <- tmp$vs1w
vs0_list_tmp[,RR] <- tmp$vs0
vs0w_list_tmp[,RR] <- tmp$vs0w
}
crps_list$ecc.s[rr,,] <- apply(crps_list_tmp, c(1,2), mean)
es_list$ecc.s[rr, ] <- apply(es_list_tmp, 1, mean)
vs1_list$ecc.s[rr, ] <- apply(vs1_list_tmp, 1, mean)
vs1w_list$ecc.s[rr, ] <- apply(vs1w_list_tmp, 1, mean)
vs0_list$ecc.s[rr, ] <- apply(vs0_list_tmp, 1, mean)
vs0w_list$ecc.s[rr, ] <- apply(vs0w_list_tmp, 1, mean)
# dECC.Q
decc.q <- mvpp(method = "dECC", ensfc = fc$ensfc, ensfc_init = fc$ensfc_init,
obs = obs$obs, obs_init = obs$obs_init, postproc_out = pp_out,
EMOS_sample = emos.q, ECC_out = ecc.q)
if(compute_crps){
crps_list$decc.q[rr, , ] <- crps_wrapper(decc.q, obs$obs)
}
tmp <- eval_all_mult(mvpp_out = decc.q, obs = obs$obs)
es_list$decc.q[rr, ] <- tmp$es
vs1_list$decc.q[rr, ] <- tmp$vs1
vs1w_list$decc.q[rr, ] <- tmp$vs1w
vs0_list$decc.q[rr, ] <- tmp$vs0
vs0w_list$decc.q[rr, ] <- tmp$vs0w
# SSh -> involves randomness -> repeat rand_rep times
es_list_tmp <- vs1_list_tmp <- vs1w_list_tmp <-
vs0_list_tmp <- vs0w_list_tmp <- matrix(NA, nrow = nout, ncol = rand_rep)
crps_list_tmp <- array(NA, dim = c(nout, d, rand_rep))
for(RR in 1:rand_rep){
ssh <- mvpp(method = "SSh", ensfc = fc$ensfc, ensfc_init = fc$ensfc_init,
obs = obs$obs, obs_init = obs$obs_init, postproc_out = pp_out,
EMOS_sample = emos.q)
if(compute_crps){
crps_list_tmp[,,RR] <- crps_wrapper(ssh, obs$obs)
}
tmp <- eval_all_mult(mvpp_out = ssh, obs = obs$obs)
es_list_tmp[,RR] <- tmp$es
vs1_list_tmp[,RR] <- tmp$vs1
vs1w_list_tmp[,RR] <- tmp$vs1w
vs0_list_tmp[,RR] <- tmp$vs0
vs0w_list_tmp[,RR] <- tmp$vs0w
}
crps_list$ssh[rr,,] <- apply(crps_list_tmp, c(1,2), mean)
es_list$ssh[rr, ] <- apply(es_list_tmp, 1, mean)
vs1_list$ssh[rr, ] <- apply(vs1_list_tmp, 1, mean)
vs1w_list$ssh[rr, ] <- apply(vs1w_list_tmp, 1, mean)
vs0_list$ssh[rr, ] <- apply(vs0_list_tmp, 1, mean)
vs0w_list$ssh[rr, ] <- apply(vs0w_list_tmp, 1, mean)
# GCA -> involves randomness -> repeat rand_rep times
es_list_tmp <- vs1_list_tmp <- vs1w_list_tmp <-
vs0_list_tmp <- vs0w_list_tmp <- matrix(NA, nrow = nout, ncol = rand_rep)
crps_list_tmp <- array(NA, dim = c(nout, d, rand_rep))
for(RR in 1:rand_rep){
gca <- mvpp(method = "GCA", ensfc = fc$ensfc, ensfc_init = fc$ensfc_init,
obs = obs$obs, obs_init = obs$obs_init, postproc_out = pp_out)
if(compute_crps){
crps_list_tmp[,,RR] <- crps_wrapper(gca, obs$obs)
}
tmp <- eval_all_mult(mvpp_out = gca, obs = obs$obs)
es_list_tmp[,RR] <- tmp$es
vs1_list_tmp[,RR] <- tmp$vs1
vs1w_list_tmp[,RR] <- tmp$vs1w
vs0_list_tmp[,RR] <- tmp$vs0
vs0w_list_tmp[,RR] <- tmp$vs0w
}
crps_list$gca[rr,,] <- apply(crps_list_tmp, c(1,2), mean)
es_list$gca[rr, ] <- apply(es_list_tmp, 1, mean)
vs1_list$gca[rr, ] <- apply(vs1_list_tmp, 1, mean)
vs1w_list$gca[rr, ] <- apply(vs1w_list_tmp, 1, mean)
vs0_list$gca[rr, ] <- apply(vs0_list_tmp, 1, mean)
vs0w_list$gca[rr, ] <- apply(vs0w_list_tmp, 1, mean)
# end loop over Monte Carlo repetitions
}
# return results, as a huge list
out <- list("crps_list" = crps_list, "es_list" = es_list, "vs1_list" = vs1_list,
"vs1w_list" = vs1w_list, "vs0_list" = vs0_list, "vs0w_list" = vs0w_list)
return(out)
}
# parameters to run
input_rho0 <- c(0.1, 0.5, 0.9)
input_eps <- c(1, 3)
input_sigma <-  sqrt(c(0.5^2, 1, 5))
input_rho <- c(0.1, 0.5, 0.9)
input_d <- 3
input_par <- expand.grid(input_rho0, input_eps, input_sigma, input_rho, input_d)
names(input_par) <- c("rho0", "eps", "sigma", "rho", "d")
MC_reps <- 10
# run
Rdata_dir <- "../Data/Rdata/" # directory to save Rdata files to
Rout_dir <- "../Data/Rout/" # directory to save Rout files to
run_wrapper <- function(runID){
sink(file = paste0(Rout_dir, "setting1_", runID, ".Rout"))
par_values <- as.numeric(input_par[ID, ])
res <- run_setting1(obsmodel = 1, fcmodel = 1, nout = 100, ninit = 50, nmembers = 10,
MCrep = MC_reps, rand_rep = 5,
progress_ind = TRUE, compute_crps = TRUE,
rho0 = input_par$rho0[runID],
rho = input_par$rho[runID],
eps = input_par$eps[runID],
sigma = input_par$sigma[runID],
d = input_par$d[runID])
savename <- paste0(Rdata_dir, "res_setting1_", runID, ".Rdata")
save(res, input_par, file = savename)
sink()
}
# wrapper function is applied to "ID". The following is tailored to running the code on an SGE HPC system.
# Alternatively, simply apply run_wrapper in a for loop over all IDs
# ID <- as.numeric(as.character(Sys.getenv(c("SGE_TASK_ID"))))
for (ID in 1:dim(input_par)[1]) {
print(ID)
run_wrapper(runID = ID)
}
#run_wrapper(runID = ID)
#for (el in ID) {
#  run_wrapper(runID = el)
#}
#if(is.element(ID, missing_settings)){
#  run_wrapper(runID = ID)
#}
# code to compute test statistics of DM tests
# results are saved in a specific data frame format to simplify plotting later on
rm(list=ls())
setwd("C:/Users/20192042/OneDrive - TU Eindhoven/Courses/BEP - BAM/Code/multiv_pp-master/processing code for simulation output")
# parameters
# Should be the same as in run_setting?.R
input_rho0 <- c(0.1, 0.5, 0.9)
input_eps <- c(0, 1, 3)
input_sigma <-  sqrt(c(0.5^2, 1, 5))
input_rho <- c(0.1, 0.5, 0.9)
input_d <- 3
input_par <- expand.grid(input_rho0, input_eps, input_sigma, input_rho, input_d)
names(input_par) <- c("rho0", "eps", "sigma", "rho", "d")
MC_reps <- 10
df_raw <- data.frame(input_par)
df_raw$simID <- 1:nrow(df_raw)
flist <- list.files("../Data/Rdata/")
existing <- as.numeric(sapply(flist, FUN = function(x) as.numeric(strsplit(strsplit(x, "_setting1_")[[1]][2], ".Rdata"))))
df <- df_raw[which(is.element(df_raw$simID, existing)),]
load("../Data/Rdata/res_setting1_1.Rdata")
input_models <- names(res$es_list)
input_scores <- names(res)
df_use <- as.data.frame(df[1,])
df_use$model <- as.character("a")
df_use$score <- as.character("a")
model_score_grid <- expand.grid(input_models, input_scores)
# Produces df of the form
#         rho0  eps   sigma   rho   d   simID   model   score
#   1     0.1   0     0.5     0.1   3   1       ens     crps_list
for(i in 1:nrow(df)){
df_use[((i-1)*nrow(model_score_grid)+1):(i*nrow(model_score_grid)),] <- df[i,]
df_use[((i-1)*nrow(model_score_grid)+1):(i*nrow(model_score_grid)),]$model <- as.character(model_score_grid$Var1)
df_use[((i-1)*nrow(model_score_grid)+1):(i*nrow(model_score_grid)),]$score <- as.character(model_score_grid$Var2)
}
# Makes a copy of df_use for each MC_rep
dfmc <- data.frame(cbind(zoo::coredata(df_use)[rep(seq(nrow(df_use)),MC_reps),]))
dfmc$value <- NA
head(dfmc)
library(forecast) # for DM test function
for(filename in flist){
load(paste0("../Data/Rdata/", filename))
ID <- as.numeric(as.numeric(strsplit(strsplit(filename, "_setting1_")[[1]][2], ".Rdata")))
print(which(flist == filename))
for(this_model in input_models){
for(this_score in input_scores){
ind <- which(dfmc$simID == ID & dfmc$model == this_model & dfmc$score == this_score)
# deal with CRPS specifically (use only first dimension, not all 5 recorded ones)
if(this_score == "crps_list"){
dm_teststat_vec <- rep(NA, MC_reps)
for(MC_rep in 1:MC_reps){
tmp <- NA
tryDM <- try(tmp_DM <- dm.test(e1 = res[[which(input_scores == this_score)]][[which(input_models == this_model)]][,,1][MC_rep,],
e2 = res[[which(input_scores == this_score)]][[which(input_models == "ecc.q")]][,,1][MC_rep,],
h = 1, power = 1), silent = TRUE)
if(class(tryDM) != "try-error"){
tmp <- tmp_DM$statistic
} else{
tmp <- 0
}
dm_teststat_vec[MC_rep] <- tmp
}
} else{
dm_teststat_vec <- rep(NA, MC_reps)
for(MC_rep in 1:MC_reps){
tmp <- NA
tryDM <- try(tmp_DM <- dm.test(e1 = res[[which(input_scores == this_score)]][[which(input_models == this_model)]][MC_rep,],
e2 = res[[which(input_scores == this_score)]][[which(input_models == "ecc.q")]][MC_rep,],
h = 1, power = 1), silent = TRUE)
if(class(tryDM) != "try-error"){
tmp <- tmp_DM$statistic
} else{
tmp <- 0
}
dm_teststat_vec[MC_rep] <- tmp
}
}
dfmc$value[ind] <- dm_teststat_vec
}
}
}
save(dfmc, file = "../Data/TestStatistic/testStatistic_setting_1.Rdata")
# code to compute test statistics of DM tests
# results are saved in a specific data frame format to simplify plotting later on
rm(list=ls())
setwd("C:/Users/20192042/OneDrive - TU Eindhoven/Courses/BEP - BAM/Code/multiv_pp-master/processing code for simulation output")
# parameters
# Should be the same as in run_setting?.R
input_rho0 <- c(0.1, 0.5, 0.9)
input_eps <- c(0, 1, 3)
input_sigma <-  sqrt(c(0.5^2, 1, 5))
input_rho <- c(0.1, 0.5, 0.9)
input_d <- 3
input_par <- expand.grid(input_rho0, input_eps, input_sigma, input_rho, input_d)
names(input_par) <- c("rho0", "eps", "sigma", "rho", "d")
MC_reps <- 10
df_raw <- data.frame(input_par)
df_raw$simID <- 1:nrow(df_raw)
flist <- list.files("../Data/Rdata/")
existing <- as.numeric(sapply(flist, FUN = function(x) as.numeric(strsplit(strsplit(x, "_setting1_")[[1]][2], ".Rdata"))))
df <- df_raw[which(is.element(df_raw$simID, existing)),]
load("../Data/Rdata/res_setting1_1.Rdata")
input_models <- names(res$es_list)
input_scores <- names(res)
df_use <- as.data.frame(df[1,])
df_use$model <- as.character("a")
df_use$score <- as.character("a")
model_score_grid <- expand.grid(input_models, input_scores)
# Produces df of the form
#         rho0  eps   sigma   rho   d   simID   model   score
#   1     0.1   0     0.5     0.1   3   1       ens     crps_list
for(i in 1:nrow(df)){
df_use[((i-1)*nrow(model_score_grid)+1):(i*nrow(model_score_grid)),] <- df[i,]
df_use[((i-1)*nrow(model_score_grid)+1):(i*nrow(model_score_grid)),]$model <- as.character(model_score_grid$Var1)
df_use[((i-1)*nrow(model_score_grid)+1):(i*nrow(model_score_grid)),]$score <- as.character(model_score_grid$Var2)
}
# Makes a copy of df_use for each MC_rep
dfmc <- data.frame(cbind(zoo::coredata(df_use)[rep(seq(nrow(df_use)),MC_reps),]))
dfmc$value <- NA
head(dfmc)
library(forecast) # for DM test function
for(filename in flist){
load(paste0("../Data/Rdata/", filename))
ID <- as.numeric(as.numeric(strsplit(strsplit(filename, "_setting1_")[[1]][2], ".Rdata")))
print(which(flist == filename))
for(this_model in input_models){
for(this_score in input_scores){
ind <- which(dfmc$simID == ID & dfmc$model == this_model & dfmc$score == this_score)
# deal with CRPS specifically (use only first dimension, not all 5 recorded ones)
if(this_score == "crps_list"){
dm_teststat_vec <- rep(NA, MC_reps)
for(MC_rep in 1:MC_reps){
tmp <- NA
tryDM <- try(tmp_DM <- dm.test(e1 = res[[which(input_scores == this_score)]][[which(input_models == this_model)]][,,1][MC_rep,],
e2 = res[[which(input_scores == this_score)]][[which(input_models == "ecc.q")]][,,1][MC_rep,],
h = 1, power = 1), silent = TRUE)
if(class(tryDM) != "try-error"){
tmp <- tmp_DM$statistic
} else{
tmp <- 0
}
dm_teststat_vec[MC_rep] <- tmp
}
} else{
dm_teststat_vec <- rep(NA, MC_reps)
for(MC_rep in 1:MC_reps){
tmp <- NA
tryDM <- try(tmp_DM <- dm.test(e1 = res[[which(input_scores == this_score)]][[which(input_models == this_model)]][MC_rep,],
e2 = res[[which(input_scores == this_score)]][[which(input_models == "ecc.q")]][MC_rep,],
h = 1, power = 1), silent = TRUE)
if(class(tryDM) != "try-error"){
tmp <- tmp_DM$statistic
} else{
tmp <- 0
}
dm_teststat_vec[MC_rep] <- tmp
}
}
dfmc$value[ind] <- dm_teststat_vec
}
}
}
save(dfmc, file = "../Data/TestStatistic/testStatistic_setting_1.Rdata")
rm(list=ls())
library(ggplot2)
library(gridExtra)
setwd("C:/Users/20192042/OneDrive - TU Eindhoven/Courses/BEP - BAM/Code/multiv_pp-master/reproducing results and figures")
load("../Data/TestStatistic/testStatistic_setting_1.Rdata")
df <- dfmc; rm(dfmc)
df1 <- subset(df, model == "ens" | model == "ecc.q" | model == "gca")
df1 <- subset(df1, score == "crps_list")
df1 <- subset(df1, eps == 1)
df1$value = (-1)*df1$value
df1$model <- factor(df1$model, levels = c("ens", "decc.q", "ecc.q", "ecc.s", "gca", "ssh"))
mypal <- c(colorspace::rainbow_hcl(5), "black")
mypal_use <- c("ens" = mypal[6],
"ecc.q" = mypal[2],
"gca" = mypal[4])
model_vec <- c("Ens.", "ECC-Q", "GCA")
p1 <- ggplot(df1, aes(model, value, colour = model))
p1
p1 <- p1 + scale_x_discrete(label = model_vec) # label = model_vec
p1
p1 <- p1 + scale_color_manual(values = mypal_use, name = "Model", label = model_vec)
p1
p1 <- p1 + geom_rect(mapping=aes(xmin=-Inf, xmax=Inf, ymin=qnorm(0.025), ymax=qnorm(0.975)), fill = "gray75", color="gray75")
p1
p1 <- p1 + geom_hline(yintercept = 0, linetype = "dashed")
p1 <- p1 + ggtitle("Setting 1, " * epsilon ~ "= 1") + geom_boxplot(outlier.shape = NA)
p1 <- p1 + xlab("Model") + ylab("DM test statistic")
g_legend<-function(a.gplot){
tmp <- ggplot_gtable(ggplot_build(a.gplot))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend <- tmp$grobs[[leg]]
legend
}
legend <- g_legend(p1)
p1_save <- p1 + theme_bw() + theme(legend.position = "none")
png("../Data/crps_settings-1.png", width = 15, height = 5, units = "in", res = 400, pointsize = 11)
grid.arrange(p1_save, p3a_save, p3b_save, legend,
ncol = 4,
widths = c(3,3,3,0.6))
# # setting 3A (was 4)
#
# load("/path/to/save/output/df_mvNormal_StructuralChage.Rdata")
#
# df <- dfmc; rm(dfmc)
# df1 <- subset(df, model == "ens" | model == "ecc.q" | model == "gca")
# df1 <- subset(df1, score == "crps_list")
#
# df1$value = (-1)*df1$value
#
# df1$model <- factor(df1$model, levels = c("ens", "decc.q", "ecc.q", "ecc.s", "gca", "ssh"))
#
# df1 <- subset(df1, model != "ecc.q")
#
# p1 <- ggplot(df1, aes(model, value, colour = model))
# p1 <- p1 + scale_x_discrete(label = model_vec) # label = model_vec
# p1 <- p1 + scale_color_manual(values = mypal_use, name = "Model", label = model_vec)
# p1 <- p1 + geom_rect(mapping=aes(xmin=-Inf, xmax=Inf, ymin=qnorm(0.025), ymax=qnorm(0.975)), fill = "gray75", color="gray75")
# p1 <- p1 + geom_hline(yintercept = 0, linetype = "dashed")
# p1 <- p1 + ggtitle(expression("Setting 3A")) + geom_boxplot(outlier.shape = NA)
# p1 <- p1 + xlab("Model") + ylab("DM test statistic") + theme_bw() + theme(legend.position = "none")
# p1
#
# p3a_save <- p1
#
# # setting 3B (new)
#
# load("/path/to/save/output/df_mvNormal_StructuralChange_B.Rdata")
#
# df <- dfmc; rm(dfmc)
# df1 <- subset(df, model == "ens" | model == "ecc.q" | model == "gca")
# df1 <- subset(df1, score == "crps_list")
#
# df1$value = (-1)*df1$value
#
# df1$model <- factor(df1$model, levels = c("ens", "decc.q", "ecc.q", "ecc.s", "gca", "ssh"))
#
# df1 <- subset(df1, model != "ecc.q")
#
# p1 <- ggplot(df1, aes(model, value, colour = model))
# p1 <- p1 + scale_x_discrete(label = model_vec) # label = model_vec
# p1 <- p1 + scale_color_manual(values = mypal_use, name = "Model", label = model_vec)
# p1 <- p1 + geom_rect(mapping=aes(xmin=-Inf, xmax=Inf, ymin=qnorm(0.025), ymax=qnorm(0.975)), fill = "gray75", color="gray75")
# p1 <- p1 + geom_hline(yintercept = 0, linetype = "dashed")
# p1 <- p1 + ggtitle(expression("Setting 3B")) + geom_boxplot(outlier.shape = NA)
# p1 <- p1 + xlab("Model") + ylab("DM test statistic") + theme_bw() + theme(legend.position = "none")
# p1
#
# p3b_save <- p1
#
# png("/path/to/figures/crps_settings-1-3A-3B.png", width = 15, height = 5, units = "in", res = 400, pointsize = 11)
# grid.arrange(p1_save, p3a_save, p3b_save, legend,
#              ncol = 4,
#              widths = c(3,3,3,0.6))
# dev.off()
png("../Data/crps_settings-1.png", width = 15, height = 5, units = "in", res = 400, pointsize = 11)
grid.arrange(p1_save, legend,
ncol = 4,
widths = c(3,3,3,0.6))
p1
rm(list=ls())
library(ggplot2)
library(gridExtra)
setwd("C:/Users/20192042/OneDrive - TU Eindhoven/Courses/BEP - BAM/Code/multiv_pp-master/reproducing results and figures")
load("../Data/TestStatistic/testStatistic_setting_1.Rdata")
df <- dfmc; rm(dfmc)
df1 <- subset(df, model == "ens" | model == "ecc.q" | model == "gca")
df1 <- subset(df1, score == "crps_list")
df1 <- subset(df1, eps == 1)
df1$value = (-1)*df1$value
df1$model <- factor(df1$model, levels = c("ens", "decc.q", "ecc.q", "ecc.s", "gca", "ssh"))
mypal <- c(colorspace::rainbow_hcl(5), "black")
mypal_use <- c("ens" = mypal[6],
"ecc.q" = mypal[2],
"gca" = mypal[4])
model_vec <- c("Ens.", "ECC-Q", "GCA")
p1 <- ggplot(df1, aes(model, value, colour = model))
p1 <- p1 + scale_x_discrete(label = model_vec) # label = model_vec
p1 <- p1 + scale_color_manual(values = mypal_use, name = "Model", label = model_vec)
p1 <- p1 + geom_rect(mapping=aes(xmin=-Inf, xmax=Inf, ymin=qnorm(0.025), ymax=qnorm(0.975)), fill = "gray75", color="gray75")
p1 <- p1 + geom_hline(yintercept = 0, linetype = "dashed")
p1 <- p1 + ggtitle("Setting 1, " * epsilon ~ "= 1") + geom_boxplot(outlier.shape = NA)
p1 <- p1 + xlab("Model") + ylab("DM test statistic")
p1
g_legend<-function(a.gplot){
tmp <- ggplot_gtable(ggplot_build(a.gplot))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend <- tmp$grobs[[leg]]
legend
}
legend <- g_legend(p1)
p1_save <- p1 + theme_bw() + theme(legend.position = "none")
p1_save
grid.arrange(p1_save, legend,
ncol = 1,
widths = c(3,3,3,0.6))
grid.arrange(p1_save, legend,
ncol = 1,
widths = c(3))
png("../Data/Plots/crps_settings-1.png", width = 15, height = 5, units = "in", res = 400, pointsize = 11)
grid.arrange(p1_save, legend,
ncol = 1,
widths = c(3))
p1_save
p1
rm(list=ls())
library(ggplot2)
library(gridExtra)
setwd("C:/Users/20192042/OneDrive - TU Eindhoven/Courses/BEP - BAM/Code/multiv_pp-master/reproducing results and figures")
load("../Data/TestStatistic/testStatistic_setting_1.Rdata")
df <- dfmc; rm(dfmc)
df1 <- subset(df, model == "ens" | model == "ecc.q" | model == "gca")
df1 <- subset(df1, score == "crps_list")
df1 <- subset(df1, eps == 1)
df1$value = (-1)*df1$value
df1$model <- factor(df1$model, levels = c("ens", "decc.q", "ecc.q", "ecc.s", "gca", "ssh"))
mypal <- c(colorspace::rainbow_hcl(5), "black")
mypal_use <- c("ens" = mypal[6],
"ecc.q" = mypal[2],
"gca" = mypal[4])
model_vec <- c("Ens.", "ECC-Q", "GCA")
p1 <- ggplot(df1, aes(model, value, colour = model))
p1 <- p1 + scale_x_discrete(label = model_vec) # label = model_vec
p1 <- p1 + scale_color_manual(values = mypal_use, name = "Model", label = model_vec)
p1 <- p1 + geom_rect(mapping=aes(xmin=-Inf, xmax=Inf, ymin=qnorm(0.025), ymax=qnorm(0.975)), fill = "gray75", color="gray75")
p1 <- p1 + geom_hline(yintercept = 0, linetype = "dashed")
p1 <- p1 + ggtitle("Setting 1, " * epsilon ~ "= 1") + geom_boxplot(outlier.shape = NA)
p1 <- p1 + xlab("Model") + ylab("DM test statistic")
p1
g_legend<-function(a.gplot){
tmp <- ggplot_gtable(ggplot_build(a.gplot))
leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
legend <- tmp$grobs[[leg]]
legend
}
legend <- g_legend(p1)
p1_save <- p1 + theme_bw() + theme(legend.position = "none")
p1_save
png("../Data/Plots/crps_settings-1.png", width = 15, height = 5, units = "in", res = 400, pointsize = 11)
grid.arrange(p1_save, legend,
ncol = 1,
widths = c(3))
p1
p1
print('hi')
sink()
print('hi')
sink()
print('hi')
